//这题的思路就是，判断一个数k是不是质数，只要用比它小的数去除它，没有一个整除就可以了
//进一步的，只要比k小的质数都不能整除它就可以
//再进一步的，我们不需要判断所有比k小的质数，只需要判断小于根号k的质数就够了

#include<stdio.h>
#include<stdbool.h>
#include<math.h>

int main(void) {
	int n;
	scanf("%d", &n);
	int num = 1;//表示已经计算的质数的个数
	int a[30005] = { 2 };
	bool is_prime;//是否为质数，学习一下这种命名的方法
	double m;//用以存储根号k
	for (int k = 3; num != n; k+=2) {//这一行看最下面注释
		is_prime = true;
		m = sqrt(k);
		for (int i = 0; i < num; i++) {
			if (k % a[i] == 0 ) {//直接可以判断不是质数
				is_prime = false;
				break;
			}
			if (a[i] > m)//直接可以判断是质数
				break;
		}
		if (is_prime)//命名的好处就体现出来了，代码可读性非常强，而且不用写is_prime==0
			a[num++] = k;//两步合一步
	}//这个循环里用到的技巧——就是这个is_prime的使用我们之前遇到过的
	printf("%d", a[num - 1]);
	return 0;
}
//题解里面有个傻逼说可以优化到只枚举6x-1和6x+1这两类数，写了一大长串去处理，你可以去看看它的代码，复杂的一b
//我一开始觉得这人就是脑子抽了   6x，6x+2，6x+3，6x+4，不就是除2除3就解决了吗，在我的代码里面也基本没有多余计算
//后来一想，确实可以根据它的这种思路作一些优化，但我只做一点，把外层for循环的k++改成k+=2，更多的优化(在细节层面的)，其实都是没事找事，既影响可读性，又浪费时间

//还有一种解法，叫作素数筛法，复杂度只有线性，非常快，但这种其实属于降维打击
//首先它的作用是把1-n之间的所有素数找出来，而不是找第几个素数，但是你一开始，如果没有数学知识储备，是不知道第30000个质数到底有多大的，这个n你没法确定，
//虽然从计算机层面，我们可以选一个很大的数字让计算机在这个范围里面寻找，但问题是，一方面，如果找的不恰当，消耗非常大，会做很多多余的计算
//另一方面，从逻辑的角度，这样的做法有点小问题，但思想很好，这种东西一般是编程竞赛的东西了，技巧性很强，并且涉及很深的数学知识的东西，我想了一下，还是只介绍一个有这个东西，具体的你自己感兴趣就去了解，因为我们现在学编程主要是为了以后工程，比如你的电气工程服务的，这种类型的知识一般是用不大上的，它只能起到一个拓展思维的作用，当前阶段花太多时间在这种可以说是奇技淫巧上，没有意义，当然，如果你想要打全国性的编程竞赛（这个对找工作特别有用，但一般能得大奖的都是提前很多年学编程的），就去深入吧